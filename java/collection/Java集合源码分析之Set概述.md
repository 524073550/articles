这篇文章是本系列的完结了，也会是读起来最轻松的文章了。因为这里只有一个概念，那就是**Set**是什么，其余的则是一些感触与总结。

# Set概述

因为**Set**的结构及实现都和**Map**保持高度一致，这里将不再对其进行分析了，感兴趣的朋友可以自行查看源码。但我们还是需要知道什么是**Set**，**Set**是一个包含不可重元素的集合，也就是所有的元素都是唯一的。还是看下文档说明吧：

> A collection that contains no duplicate elements.  More formally, sets contain no pair of elements **e1** and **e2** such that ***e1.equals(e2)***, and at most one null element.  As implied by its name, this interface models the mathematical **set** abstraction.

此外**Set**系列也有`SortedSet`、`NavigableSet`这种基于排序的接口，它们的作用在分析**Map**时都已经详细介绍过了。

# 总结

分析了这么多集合类的源码之后，最大的感触并不是，“哦，原来如此~”，而是惊叹于作者高度的抽象思维，严谨的代码，以及极其规范的编码风格。代码本身的价值远远比不上这种思想带来的受益，我们应该掌握的是这些原理，而不是记住枯燥的代码实现。

但惊艳的背后，作者付出的艰辛也是无比巨大的，其中也饱含辛酸与无奈。创造出那么多的数据结构，不就是为了提高处理数据的能力吗？然而现实是如果想在一方面追求极致，就必须在其他方面有所妥协，没有一种结构能够让我们一劳永逸。所以需求无尽，探索无尽。可还记得在`LinkedList`中的查询方法？在这么小的点上，还尽力把查询速度提升了一半，当时真的被这种操作惊艳了，一方面是因为工程师的细腻，另一方面，可能是因为，“哎，实在做不了更多了~”的感叹。

在Java的集合类中，大量的依赖于对象的`equals`、`hashCode`、`clone`方法，有些还需要我们实现`Comparable`接口。如果对数据结构有所理解，又清楚集合类用了哪些个数据结构，我想需要实现哪些方法是可以推测出来的。如果我们能把握这些细节，就能写出更优秀的代码。如果我们能掌握这些思想，就能超脱语言的束缚，理解软件设计的精髓。

如果阅读本系列文章能够给您带来一丁点的提升，对我都是莫大的欣慰与鼓励。

**现在，你有把握回答在开篇中提及的几个问题了吗？**

---

本文到此就结束了，如果您喜欢我的文章，可以关注我的微信公众号： **大大纸飞机** 

或者扫描下方二维码直接添加：

<div align="center"><img src ="./image/qrcode.jpg" /><br/>扫描二维码关注</div>

您也可以关注我的简书：https://www.jianshu.com/u/9ee83a8ee52d

编程之路，道阻且长。唯，路漫漫其修远兮，吾将上下而求索。